//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Microsoft.Extensions.DependencyInjection
{
    public static partial class EnrichmentServiceCollectionExtensions
    {
        public static IServiceCollection AddLogEnricher(this IServiceCollection services, Diagnostics.Enrichment.ILogEnricher enricher) { throw null; }

        public static IServiceCollection AddLogEnricher<T>(this IServiceCollection services)
            where T : class, Diagnostics.Enrichment.ILogEnricher { throw null; }

        public static IServiceCollection AddStaticLogEnricher(this IServiceCollection services, Diagnostics.Enrichment.IStaticLogEnricher enricher) { throw null; }

        public static IServiceCollection AddStaticLogEnricher<T>(this IServiceCollection services)
            where T : class, Diagnostics.Enrichment.IStaticLogEnricher { throw null; }
    }

    public static partial class LatencyRegistryServiceCollectionExtensions
    {
        public static IServiceCollection RegisterCheckpointNames(this IServiceCollection services, params string[] names) { throw null; }

        public static IServiceCollection RegisterMeasureNames(this IServiceCollection services, params string[] names) { throw null; }

        public static IServiceCollection RegisterTagNames(this IServiceCollection services, params string[] names) { throw null; }
    }

    public static partial class NullLatencyContextServiceCollectionExtensions
    {
        public static IServiceCollection AddNullLatencyContext(this IServiceCollection services) { throw null; }
    }
}

namespace Microsoft.Extensions.Diagnostics.Enrichment
{
    public partial interface IEnrichmentTagCollector
    {
        void Add(string tagName, object tagValue);
    }

    public partial interface ILogEnricher
    {
        void Enrich(IEnrichmentTagCollector collector);
    }

    public partial interface IStaticLogEnricher
    {
        void Enrich(IEnrichmentTagCollector collector);
    }
}

namespace Microsoft.Extensions.Diagnostics.Latency
{
    public readonly partial struct Checkpoint : System.IEquatable<Checkpoint>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Checkpoint(string name, long elapsed, long frequency) { }

        public long Elapsed { get { throw null; } }

        public long Frequency { get { throw null; } }

        public string Name { get { throw null; } }

        public readonly bool Equals(Checkpoint other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }

        public static bool operator ==(Checkpoint left, Checkpoint right) { throw null; }

        public static bool operator !=(Checkpoint left, Checkpoint right) { throw null; }
    }

    public readonly partial struct CheckpointToken
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public CheckpointToken(string name, int position) { }

        public string Name { get { throw null; } }

        public int Position { get { throw null; } }
    }

    public partial interface ILatencyContext : System.IDisposable
    {
        LatencyData LatencyData { get; }

        void AddCheckpoint(CheckpointToken token);
        void AddMeasure(MeasureToken token, long value);
        void Freeze();
        void RecordMeasure(MeasureToken token, long value);
        void SetTag(TagToken token, string value);
    }

    public partial interface ILatencyContextProvider
    {
        ILatencyContext CreateContext();
    }

    public partial interface ILatencyContextTokenIssuer
    {
        CheckpointToken GetCheckpointToken(string name);
        MeasureToken GetMeasureToken(string name);
        TagToken GetTagToken(string name);
    }

    public partial interface ILatencyDataExporter
    {
        System.Threading.Tasks.Task ExportAsync(LatencyData data, System.Threading.CancellationToken cancellationToken);
    }

    public partial class LatencyContextRegistrationOptions
    {
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IReadOnlyList<string> CheckpointNames { get { throw null; } set { } }

        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IReadOnlyList<string> MeasureNames { get { throw null; } set { } }

        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.IReadOnlyList<string> TagNames { get { throw null; } set { } }
    }

    public readonly partial struct LatencyData
    {
        private readonly int _dummyPrimitive;
        public LatencyData(System.ArraySegment<Tag> tags, System.ArraySegment<Checkpoint> checkpoints, System.ArraySegment<Measure> measures, long durationTimestamp, long durationTimestampFrequency) { }

        public System.ReadOnlySpan<Checkpoint> Checkpoints { get { throw null; } }

        public long DurationTimestamp { get { throw null; } }

        public long DurationTimestampFrequency { get { throw null; } }

        public System.ReadOnlySpan<Measure> Measures { get { throw null; } }

        public System.ReadOnlySpan<Tag> Tags { get { throw null; } }
    }

    public readonly partial struct Measure : System.IEquatable<Measure>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Measure(string name, long value) { }

        public string Name { get { throw null; } }

        public long Value { get { throw null; } }

        public readonly bool Equals(Measure other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }

        public static bool operator ==(Measure left, Measure right) { throw null; }

        public static bool operator !=(Measure left, Measure right) { throw null; }
    }

    public readonly partial struct MeasureToken
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public MeasureToken(string name, int position) { }

        public string Name { get { throw null; } }

        public int Position { get { throw null; } }
    }

    public readonly partial struct Tag
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Tag(string name, string value) { }

        public string Name { get { throw null; } }

        public string Value { get { throw null; } }
    }

    public readonly partial struct TagToken
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public TagToken(string name, int position) { }

        public string Name { get { throw null; } }

        public int Position { get { throw null; } }
    }
}

namespace Microsoft.Extensions.Diagnostics.Metrics
{
    [System.AttributeUsage(System.AttributeTargets.Method)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class CounterAttribute : System.Attribute
    {
        public CounterAttribute(params string[] tagNames) { }

        public CounterAttribute(System.Type type) { }

        public string? Name { get { throw null; } set { } }

        public string[]? TagNames { get { throw null; } }

        public System.Type? Type { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Method)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class CounterAttribute<T> : System.Attribute where T : struct
    {
        public CounterAttribute(params string[] tagNames) { }

        public CounterAttribute(System.Type type) { }

        public string? Name { get { throw null; } set { } }

        public string[]? TagNames { get { throw null; } }

        public System.Type? Type { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Method)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class GaugeAttribute : System.Attribute
    {
        public GaugeAttribute(params string[] tagNames) { }

        public GaugeAttribute(System.Type type) { }

        public string? Name { get { throw null; } set { } }

        public string[]? TagNames { get { throw null; } }

        public System.Type? Type { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Method)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class HistogramAttribute : System.Attribute
    {
        public HistogramAttribute(params string[] tagNames) { }

        public HistogramAttribute(System.Type type) { }

        public string? Name { get { throw null; } set { } }

        public string[]? TagNames { get { throw null; } }

        public System.Type? Type { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Method)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class HistogramAttribute<T> : System.Attribute where T : struct
    {
        public HistogramAttribute(params string[] tagNames) { }

        public HistogramAttribute(System.Type type) { }

        public string? Name { get { throw null; } set { } }

        public string[]? TagNames { get { throw null; } }

        public System.Type? Type { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Property | System.AttributeTargets.Field)]
    public sealed partial class TagNameAttribute : System.Attribute
    {
        public TagNameAttribute(string name) { }

        public string Name { get { throw null; } }
    }
}

namespace Microsoft.Extensions.Http.Diagnostics
{
    public enum HttpRouteParameterRedactionMode
    {
        Strict = 0,
        Loose = 1,
        None = 2
    }

    public partial interface IDownstreamDependencyMetadata
    {
        string DependencyName { get; }

        System.Collections.Generic.ISet<RequestMetadata> RequestMetadata { get; }

        System.Collections.Generic.ISet<string> UniqueHostNameSuffixes { get; }
    }

    public partial interface IOutgoingRequestContext
    {
        RequestMetadata? RequestMetadata { get; }

        void SetRequestMetadata(RequestMetadata metadata);
    }

    public partial class RequestMetadata
    {
        public RequestMetadata() { }

        public RequestMetadata(string methodType, string requestRoute, string requestName = "unknown") { }

        public string DependencyName { get { throw null; } set { } }

        public string MethodType { get { throw null; } set { } }

        public string RequestName { get { throw null; } set { } }

        public string RequestRoute { get { throw null; } set { } }
    }

    public static partial class TelemetryConstants
    {
        public const string ClientApplicationNameHeader = "X-ClientApplication";
        public const string Redacted = "REDACTED";
        public const string RequestMetadataKey = "Extensions-RequestMetadata";
        public const string ServerApplicationNameHeader = "X-ServerApplication";
        public const string Unknown = "unknown";
    }
}

namespace Microsoft.Extensions.Logging
{
    public partial interface ITagCollector
    {
        void Add(string tagName, object? tagValue, Compliance.Classification.DataClassificationSet classifications);
        void Add(string tagName, object? tagValue);
    }

    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public static partial class LoggerMessageHelper
    {
        public static LoggerMessageState ThreadLocalState { get { throw null; } }

        public static string Stringify(System.Collections.IEnumerable? enumerable) { throw null; }

        public static string Stringify<TKey, TValue>(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>? enumerable) { throw null; }
    }

    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    public sealed partial class LoggerMessageState : Diagnostics.Enrichment.IEnrichmentTagCollector, System.Collections.Generic.IReadOnlyList<System.Collections.Generic.KeyValuePair<string, object?>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, object?>>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<string, object?>>, ITagCollector
    {
        public ClassifiedTag[] ClassifiedTagArray { get { throw null; } }

        public int ClassifiedTagsCount { get { throw null; } }

        public System.Collections.Generic.KeyValuePair<string, object?> this[int index] { get { throw null; } }

        public System.Collections.Generic.KeyValuePair<string, object?>[] RedactedTagArray { get { throw null; } }

        int System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<string, object>>.Count { get { throw null; } }

        public System.Collections.Generic.KeyValuePair<string, object?>[] TagArray { get { throw null; } }

        public string TagNamePrefix { get { throw null; } set { } }

        public int TagsCount { get { throw null; } }

        public void AddClassifiedTag(string name, object? value, Compliance.Classification.DataClassificationSet classifications) { }

        public void AddTag(string name, object? value) { }

        public void Clear() { }

        void Diagnostics.Enrichment.IEnrichmentTagCollector.Add(string key, object value) { }

        void ITagCollector.Add(string tagName, object? tagValue, Compliance.Classification.DataClassificationSet classifications) { }

        void ITagCollector.Add(string tagName, object? tagValue) { }

        public int ReserveClassifiedTagSpace(int count) { throw null; }

        public int ReserveTagSpace(int count) { throw null; }

        System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, object>>.GetEnumerator() { throw null; }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }

        public override string ToString() { throw null; }

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public readonly partial struct ClassifiedTag
        {
            private readonly object _dummy;
            private readonly int _dummyPrimitive;
            public ClassifiedTag(string name, object? value, Compliance.Classification.DataClassificationSet classifications) { }

            public Compliance.Classification.DataClassificationSet Classifications { get { throw null; } }

            public string Name { get { throw null; } }

            public object? Value { get { throw null; } }
        }
    }

    public abstract partial class LoggingSampler
    {
        public abstract bool ShouldSample<TState>(in Abstractions.LogEntry<TState> logEntry);
    }

    [System.AttributeUsage(System.AttributeTargets.Property | System.AttributeTargets.Parameter)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class LogPropertiesAttribute : System.Attribute
    {
        public bool OmitReferenceName { get { throw null; } set { } }

        public bool SkipNullProperties { get { throw null; } set { } }

        [System.Diagnostics.CodeAnalysis.Experimental("EXTEXP0003", UrlFormat = "https://aka.ms/dotnet-extensions-warnings/{0}")]
        public bool Transitive { get { throw null; } set { } }
    }

    [System.AttributeUsage(System.AttributeTargets.Property)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class LogPropertyIgnoreAttribute : System.Attribute
    {
    }

    [System.AttributeUsage(System.AttributeTargets.Property | System.AttributeTargets.Parameter)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class TagNameAttribute : System.Attribute
    {
        public TagNameAttribute(string name) { }

        public string Name { get { throw null; } }
    }

    [System.AttributeUsage(System.AttributeTargets.Property | System.AttributeTargets.Parameter)]
    [System.Diagnostics.Conditional("CODE_GENERATION_ATTRIBUTES")]
    public sealed partial class TagProviderAttribute : System.Attribute
    {
        public TagProviderAttribute(System.Type providerType, string providerMethod) { }

        public bool OmitReferenceName { get { throw null; } set { } }

        public string ProviderMethod { get { throw null; } }

        public System.Type ProviderType { get { throw null; } }
    }
}