//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Microsoft.Extensions.DependencyInjection
{
    public static partial class FakeLoggerServiceCollectionExtensions
    {
        public static IServiceCollection AddFakeLogging(this IServiceCollection services, Configuration.IConfigurationSection section) { throw null; }

        public static IServiceCollection AddFakeLogging(this IServiceCollection services, System.Action<Logging.Testing.FakeLogCollectorOptions> configure) { throw null; }

        public static IServiceCollection AddFakeLogging(this IServiceCollection services) { throw null; }
    }
}

namespace Microsoft.Extensions.Diagnostics.Metrics.Testing
{
    [System.Diagnostics.DebuggerDisplay("{DebuggerToString(),nq}")]
    public sealed partial class CollectedMeasurement<T>
        where T : struct
    {
        internal CollectedMeasurement() { }

        public System.Collections.Generic.IReadOnlyDictionary<string, object?> Tags { get { throw null; } }

        public System.DateTimeOffset Timestamp { get { throw null; } }

        public T Value { get { throw null; } }

        public bool ContainsTags(params System.Collections.Generic.KeyValuePair<string, object?>[] tags) { throw null; }

        public bool ContainsTags(params string[] tags) { throw null; }

        public bool MatchesTags(params System.Collections.Generic.KeyValuePair<string, object?>[] tags) { throw null; }

        public bool MatchesTags(params string[] tags) { throw null; }
    }

    public static partial class MeasurementExtensions
    {
        public static System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> ContainsTags<T>(this System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> measurements, params System.Collections.Generic.KeyValuePair<string, object?>[] tags)
            where T : struct { throw null; }

        public static System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> ContainsTags<T>(this System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> measurements, params string[] tags)
            where T : struct { throw null; }

        public static T EvaluateAsCounter<T>(this System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> measurements)
            where T : struct { throw null; }

        public static System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> MatchesTags<T>(this System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> measurements, params System.Collections.Generic.KeyValuePair<string, object?>[] tags)
            where T : struct { throw null; }

        public static System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> MatchesTags<T>(this System.Collections.Generic.IEnumerable<CollectedMeasurement<T>> measurements, params string[] tags)
            where T : struct { throw null; }
    }

    [System.Diagnostics.DebuggerDisplay("{_measurements.Count} measurements")]
    public sealed partial class MetricCollector<T> : System.IDisposable where T : struct
    {
        public MetricCollector(System.Diagnostics.Metrics.Instrument<T> instrument, System.TimeProvider? timeProvider = null) { }

        public MetricCollector(System.Diagnostics.Metrics.Meter meter, string instrumentName, System.TimeProvider? timeProvider = null) { }

        public MetricCollector(System.Diagnostics.Metrics.ObservableInstrument<T> instrument, System.TimeProvider? timeProvider = null) { }

        public MetricCollector(object? meterScope, string meterName, string instrumentName, System.TimeProvider? timeProvider = null) { }

        public System.Diagnostics.Metrics.Instrument? Instrument { get { throw null; } }

        public CollectedMeasurement<T>? LastMeasurement { get { throw null; } }

        public void Clear() { }

        public void Dispose() { }

        public System.Collections.Generic.IReadOnlyList<CollectedMeasurement<T>> GetMeasurementSnapshot(bool clear = false) { throw null; }

        public void RecordObservableInstruments() { }

        public System.Threading.Tasks.Task WaitForMeasurementsAsync(int minCount, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public System.Threading.Tasks.Task WaitForMeasurementsAsync(int minCount, System.TimeSpan timeout) { throw null; }
    }
}

namespace Microsoft.Extensions.Logging
{
    public static partial class FakeLoggerBuilderExtensions
    {
        public static ILoggingBuilder AddFakeLogging(this ILoggingBuilder builder, Configuration.IConfigurationSection section) { throw null; }

        public static ILoggingBuilder AddFakeLogging(this ILoggingBuilder builder, System.Action<Testing.FakeLogCollectorOptions> configure) { throw null; }

        public static ILoggingBuilder AddFakeLogging(this ILoggingBuilder builder) { throw null; }
    }
}

namespace Microsoft.Extensions.Logging.Testing
{
    [System.Diagnostics.DebuggerDisplay("Count = {Count}, LatestRecord = {LatestRecord}")]
    public partial class FakeLogCollector
    {
        public FakeLogCollector() { }

        public FakeLogCollector(Options.IOptions<FakeLogCollectorOptions> options) { }

        public int Count { get { throw null; } }

        public FakeLogRecord LatestRecord { get { throw null; } }

        public void Clear() { }

        public static FakeLogCollector Create(FakeLogCollectorOptions options) { throw null; }

        public System.Collections.Generic.IReadOnlyList<FakeLogRecord> GetSnapshot(bool clear = false) { throw null; }
    }

    public partial class FakeLogCollectorOptions
    {
        public bool CollectRecordsForDisabledLogLevels { get { throw null; } set { } }

        public System.Collections.Generic.ISet<string> FilteredCategories { get { throw null; } set { } }

        public System.Collections.Generic.ISet<LogLevel> FilteredLevels { get { throw null; } set { } }

        public System.Func<FakeLogRecord, string> OutputFormatter { get { throw null; } set { } }

        public System.Action<string>? OutputSink { get { throw null; } set { } }

        public System.TimeProvider TimeProvider { get { throw null; } set { } }
    }

    public partial class FakeLogger : ILogger
    {
        public FakeLogger(FakeLogCollector? collector = null, string? category = null) { }

        public FakeLogger(System.Action<string> outputSink, string? category = null) { }

        public string? Category { get { throw null; } }

        public FakeLogCollector Collector { get { throw null; } }

        public FakeLogRecord LatestRecord { get { throw null; } }

        public System.IDisposable? BeginScope<TState>(TState state) { throw null; }

        public void ControlLevel(LogLevel logLevel, bool enabled) { }

        public bool IsEnabled(LogLevel logLevel) { throw null; }

        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, System.Exception? exception, System.Func<TState, System.Exception?, string> formatter) { }
    }

    [ProviderAlias("Fake")]
    public partial class FakeLoggerProvider : ILoggerProvider, System.IDisposable, ISupportExternalScope
    {
        public FakeLoggerProvider(FakeLogCollector? collector = null) { }

        public FakeLogCollector Collector { get { throw null; } }

        public FakeLogger CreateLogger(string? categoryName) { throw null; }

        public void Dispose() { }

        protected virtual void Dispose(bool disposing) { }

        [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
        ~FakeLoggerProvider() {
        }

        ILogger ILoggerProvider.CreateLogger(string categoryName) { throw null; }

        public void SetScopeProvider(IExternalScopeProvider scopeProvider) { }
    }

    public sealed partial class FakeLogger<T> : FakeLogger, ILogger<T>, ILogger
    {
        public FakeLogger(FakeLogCollector? collector = null) : base(default(FakeLogCollector?), default) { }

        public FakeLogger(System.Action<string> outputSink) : base(default(FakeLogCollector?), default) { }
    }

    public partial class FakeLogRecord
    {
        public FakeLogRecord(LogLevel level, EventId id, object? state, System.Exception? exception, string message, System.Collections.Generic.IReadOnlyList<object?> scopes, string? category, bool enabled, System.DateTimeOffset timestamp) { }

        public string? Category { get { throw null; } }

        public System.Exception? Exception { get { throw null; } }

        public EventId Id { get { throw null; } }

        public LogLevel Level { get { throw null; } }

        public bool LevelEnabled { get { throw null; } }

        public string Message { get { throw null; } }

        public System.Collections.Generic.IReadOnlyList<object?> Scopes { get { throw null; } }

        public object? State { get { throw null; } }

        public System.Collections.Generic.IReadOnlyList<System.Collections.Generic.KeyValuePair<string, string?>>? StructuredState { get { throw null; } }

        public System.DateTimeOffset Timestamp { get { throw null; } }

        public string? GetStructuredStateValue(string key) { throw null; }

        public override string ToString() { throw null; }
    }
}

namespace System
{
    public static partial class FakeLoggerServiceProviderExtensions
    {
        public static Microsoft.Extensions.Logging.Testing.FakeLogCollector GetFakeLogCollector(this IServiceProvider services) { throw null; }
    }
}